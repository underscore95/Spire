#version 460
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_KHR_vulkan_glsl : enable

#include "ShaderInfo.h"

layout (set = SPIRE_VOXEL_SHADER_BINDINGS_GREEDY_MESHING_SET, binding = SPIRE_VOXEL_SHADER_BINDINGS_GREEDY_MESHING_VOXEL_DATA_INPUT) readonly buffer ChunkVoxelData {
    GPUChunkVoxelData data;
} chunkVoxelData;

layout (set = SPIRE_VOXEL_SHADER_BINDINGS_GREEDY_MESHING_SET, binding = SPIRE_VOXEL_SHADER_BINDINGS_GREEDY_MESHING_OUTPUT) buffer Output {
    uint64_t grid[SPIRE_VOXEL_CHUNK_SIZE * SPIRE_VOXEL_CHUNK_AREA * SPIRE_VOXEL_NUM_FACES];
} greedyMeshOutput;

layout (local_size_x = SPIRE_VOXEL_CHUNK_SIZE, local_size_y = SPIRE_VOXEL_NUM_FACES, local_size_z = 1) in;

const uint64_t UINT64_ONE = uint64_t(1);

// convert slice, row, col, face into chunk coords (0 to 63)
uvec3 GreedyGridGetChunkCoords(uint slice, uint row, uint col, uint face) {
    if (face == SPIRE_VOXEL_FACE_POS_Z || face == SPIRE_VOXEL_FACE_NEG_Z) {
        return uvec3(col, row, slice);
    } else if (face == SPIRE_VOXEL_FACE_POS_X || face == SPIRE_VOXEL_FACE_NEG_X) {
        return uvec3(slice, row, col);
    } else {
        return uvec3(col, slice, row);
    }
}

uint getVoxelType(uint voxelDataIndex) {
    uvec4 possibleVoxelTypes = chunkVoxelData.data.Data[voxelDataIndex / SPIRE_UVEC4_LENGTH];
    return possibleVoxelTypes[voxelDataIndex % SPIRE_UVEC4_LENGTH];
}

void main() {
    const uint slice = gl_LocalInvocationID.x;
    const uint face = gl_LocalInvocationID.y;
    const uint index = GreedyGridGetGridStartingIndex(face, slice);

    for (uint row = 0; row < SPIRE_VOXEL_CHUNK_SIZE; row++) {
        for (uint col = 0; col < SPIRE_VOXEL_CHUNK_SIZE; col++) {
            ivec3 chunkCoords = ivec3(GreedyGridGetChunkCoords(slice, row, col, face));
            ivec3 adjacentPositive = chunkCoords + FaceToDirection(face);

            bool adjacentPositiveIsPresent = adjacentPositive.x < SPIRE_VOXEL_CHUNK_SIZE
            &&    adjacentPositive.y < SPIRE_VOXEL_CHUNK_SIZE
            &&  adjacentPositive.z < SPIRE_VOXEL_CHUNK_SIZE
            &&  getVoxelType(SPIRE_VOXEL_POSITION_TO_INDEX(adjacentPositive)) != 0;

            if (getVoxelType(SPIRE_VOXEL_POSITION_TO_INDEX(chunkCoords)) != 0 && !adjacentPositiveIsPresent) {
                greedyMeshOutput.grid[index + col] |= UINT64_ONE << uint64_t(row);// set bit
            }
        }
    }
}